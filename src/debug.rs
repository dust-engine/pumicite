//! Debug utilities.
//!
//! This module provides debug messaging and object naming for improved developer experience.
//!
//! # Debug Messenger
//!
//! The [`DebugUtilsMessenger`] captures messages from Vulkan validation layers
//! and the driver, routing them to registered callbacks for logging or custom handling.
//!
//! # Object Naming
//!
//! The [`DebugObject`] trait provides methods to assign debug names to Vulkan objects.
//! These names appear in validation messages and debugging tools like RenderDoc and NSight.
//!
//! # Requirements
//!
//! Requires the `VK_EXT_debug_utils` extension to be enabled on the instance.

use ash::{VkResult, vk};
use std::ffi::CStr;

use std::sync::RwLock;

use crate::Instance;
use ash::ext::debug_utils::Meta as DebugUtilsExt;

/// A callback function type for handling Vulkan debug messages.
///
/// This function is called whenever the Vulkan validation layers or driver
/// generates a debug message. The callback receives information about the
/// message severity, type, and detailed data about the triggering event.
///
/// # Parameters
///
/// * `severity` - The severity level of the message (verbose, info, warning, error)
/// * `types` - The type of message (general, validation, performance)
/// * `callback_data` - Detailed information about the debug message
pub type DebugUtilsMessengerCallback = fn(
    severity: vk::DebugUtilsMessageSeverityFlagsEXT,
    types: vk::DebugUtilsMessageTypeFlagsEXT,
    callback_data: &DebugUtilsMessengerCallbackData,
);

/// Contains information about a Vulkan debug message.
///
/// This structure is passed to debug callback functions and provides
/// information about the context and details of a debug message generated by
/// the Vulkan validation layers or driver.
pub struct DebugUtilsMessengerCallbackData<'a> {
    /// Reference to the Vulkan instance that generated this debug message
    pub instance: &'a Instance,

    /// Identifies the particular message ID that is associated with the provided message.
    /// If the message corresponds to a validation layer message, then this string may contain
    /// the portion of the Vulkan specification that is believed to have been violated.
    pub message_id_name: Option<&'a CStr>,

    /// The ID number of the triggering message. If the message corresponds to a validation layer
    /// message, then this number is related to the internal number associated with the message
    /// being triggered.
    pub message_id_number: i32,

    /// Details on the trigger conditions - the actual debug message content
    pub message: Option<&'a CStr>,

    /// Array of active queue debug labels at the time the message was triggered.
    /// These labels help identify which queue operations were active when the message occurred.
    pub queue_labels: &'a [vk::DebugUtilsLabelEXT<'a>],

    /// Array of active command buffer debug labels at the time the message was triggered.
    /// These labels help identify which command buffer operations were active when the message occurred.
    pub cmd_buf_labels: &'a [vk::DebugUtilsLabelEXT<'a>],

    /// Array of Vulkan objects related to the debug message.
    /// These objects provide context about which specific Vulkan resources are involved.
    pub objects: &'a [vk::DebugUtilsObjectNameInfoEXT<'a>],
}

/// A Vulkan debug utils messenger that handles debug messages from validation layers.
///
/// This struct manages the lifecycle of a Vulkan debug messenger and maintains
/// a collection of callback functions that are invoked when debug messages are generated.
/// The messenger automatically registers with the Vulkan instance and forwards
/// all debug messages to the registered callbacks.
pub struct DebugUtilsMessenger(Box<DebugUtilsMessengerInner>);

struct DebugUtilsMessengerInner {
    instance: Instance,
    messenger: vk::DebugUtilsMessengerEXT,
    callbacks: RwLock<Vec<DebugUtilsMessengerCallback>>,
}
impl Drop for DebugUtilsMessenger {
    fn drop(&mut self) {
        unsafe {
            self.0
                .instance
                .extension::<DebugUtilsExt>()
                .destroy_debug_utils_messenger(self.0.messenger, None);
        }
    }
}

impl DebugUtilsMessenger {
    /// Creates a new debug utils messenger for the given Vulkan instance.
    ///
    /// This method sets up a debug messenger that will capture all types of debug messages
    /// (general, validation, and performance) at all severity levels (verbose, info, warning, error).
    /// A default callback is automatically registered that logs messages using the `log` crate.
    pub fn new(instance: Instance) -> VkResult<Self> {
        let mut this = Box::new(DebugUtilsMessengerInner {
            instance,
            messenger: vk::DebugUtilsMessengerEXT::default(),
            callbacks: RwLock::new(vec![default_callback]),
        });
        let messenger = unsafe {
            let p_user_data =
                this.as_mut() as *mut DebugUtilsMessengerInner as *mut std::ffi::c_void;
            // Safety:
            // The application must ensure that vkCreateDebugUtilsMessengerEXT is not executed in parallel
            // with any Vulkan command that is also called with instance or child of instance as the dispatchable argument.
            // We do this by taking a mutable reference to Instance.
            this.instance
                .extension::<DebugUtilsExt>()
                .create_debug_utils_messenger(
                    &vk::DebugUtilsMessengerCreateInfoEXT {
                        message_severity: vk::DebugUtilsMessageSeverityFlagsEXT::VERBOSE
                            | vk::DebugUtilsMessageSeverityFlagsEXT::INFO
                            | vk::DebugUtilsMessageSeverityFlagsEXT::WARNING
                            | vk::DebugUtilsMessageSeverityFlagsEXT::ERROR,
                        message_type: vk::DebugUtilsMessageTypeFlagsEXT::GENERAL
                            | vk::DebugUtilsMessageTypeFlagsEXT::VALIDATION
                            | vk::DebugUtilsMessageTypeFlagsEXT::PERFORMANCE,
                        pfn_user_callback: Some(debug_utils_callback),
                        // This is self-referencing: Self contains `vk::DebugUtilsMessengerEXT` which then
                        // contains a pointer to Self. It's fine because Self was boxed.
                        p_user_data,
                        ..Default::default()
                    },
                    None,
                )?
        };
        this.messenger = messenger;
        Ok(Self(this))
    }
    /// Adds a custom callback function to handle debug messages.
    ///
    /// The callback will be invoked for all debug messages received by this messenger,
    /// in addition to any previously registered callbacks. Multiple callbacks can be
    /// registered and they will all be called in the order they were added.
    pub fn add_callback(&self, callback: DebugUtilsMessengerCallback) {
        let mut callbacks = self.0.callbacks.write().unwrap();
        callbacks.push(callback);
    }
}

/// Internal system callback function that receives debug messages from Vulkan.
///
/// This function is registered with the Vulkan debug utils extension and serves as
/// the bridge between the Vulkan validation layers and our Rust callback system.
/// Whenever we receive a debug callback from Vulkan, we create safe Rust types and
/// dispatch the message to all registered debug callbacks.
#[allow(unsafe_op_in_unsafe_fn)]
unsafe extern "system" fn debug_utils_callback(
    severity: vk::DebugUtilsMessageSeverityFlagsEXT,
    types: vk::DebugUtilsMessageTypeFlagsEXT,
    callback_data: *const vk::DebugUtilsMessengerCallbackDataEXT,
    user_data: *mut std::ffi::c_void,
) -> vk::Bool32 {
    let this: &DebugUtilsMessengerInner =
        &*(user_data as *mut DebugUtilsMessengerInner as *const DebugUtilsMessengerInner);
    let callback_data_raw = &*callback_data;
    let callback_data = DebugUtilsMessengerCallbackData {
        instance: &this.instance,
        message_id_number: callback_data_raw.message_id_number,
        message_id_name: if callback_data_raw.p_message_id_name.is_null() {
            None
        } else {
            Some(CStr::from_ptr(callback_data_raw.p_message_id_name))
        },
        message: if callback_data_raw.p_message.is_null() {
            None
        } else {
            Some(CStr::from_ptr(callback_data_raw.p_message))
        },
        queue_labels: if callback_data_raw.queue_label_count == 0 {
            &[]
        } else {
            std::slice::from_raw_parts(
                callback_data_raw.p_queue_labels,
                callback_data_raw.queue_label_count as usize,
            )
        },
        cmd_buf_labels: if callback_data_raw.queue_label_count == 0 {
            &[]
        } else {
            std::slice::from_raw_parts(
                callback_data_raw.p_cmd_buf_labels,
                callback_data_raw.cmd_buf_label_count as usize,
            )
        },
        objects: if callback_data_raw.queue_label_count == 0 {
            &[]
        } else {
            std::slice::from_raw_parts(
                callback_data_raw.p_objects,
                callback_data_raw.object_count as usize,
            )
        },
    };
    for callback in this.callbacks.read().unwrap().iter() {
        (callback)(severity, types, &callback_data)
    }
    // The callback returns a VkBool32, which is interpreted in a layer-specified manner.
    // The application should always return VK_FALSE. The VK_TRUE value is reserved for use in layer development.
    vk::FALSE
}

/// Default debug callback that logs messages using the [`log`] crate.
///
/// This callback is automatically registered when creating a new [`DebugUtilsMessenger`].
fn default_callback(
    severity: vk::DebugUtilsMessageSeverityFlagsEXT,
    types: vk::DebugUtilsMessageTypeFlagsEXT,
    callback_data: &DebugUtilsMessengerCallbackData,
) {
    use log::Level;
    let level = match severity {
        vk::DebugUtilsMessageSeverityFlagsEXT::VERBOSE => Level::Debug,
        vk::DebugUtilsMessageSeverityFlagsEXT::INFO => Level::Info,
        vk::DebugUtilsMessageSeverityFlagsEXT::WARNING => Level::Warn,
        vk::DebugUtilsMessageSeverityFlagsEXT::ERROR => Level::Error,
        _ => Level::Trace,
    };

    let target = match types {
        vk::DebugUtilsMessageTypeFlagsEXT::GENERAL => "vulkan_message",
        vk::DebugUtilsMessageTypeFlagsEXT::VALIDATION => "vulkan_validation",
        vk::DebugUtilsMessageTypeFlagsEXT::PERFORMANCE => "vulkan_performance",
        _ => "vulkan",
    };

    log::log!(
        target: target,
        level,
        message_type:? = types,
        message_id_number = callback_data.message_id_number,
        message_id_name = callback_data.message_id_name.and_then(|x| x.to_str().ok()).unwrap_or("Unknown Message Type");
        "{}",
        callback_data.message.and_then(|x| x.to_str().ok()).unwrap_or_default(),
    );

    if level == Level::Error {
        let bt = std::backtrace::Backtrace::capture();
        if bt.status() == std::backtrace::BacktraceStatus::Captured {
            println!("{bt}");
        }
    }
}

/// A trait for Vulkan objects that can be associated with debug names for easier identification.
///
/// This trait provides convenient methods for setting, updating, and removing debug names
/// from Vulkan objects. Debug names are useful during development and debugging
/// as they allow you to identify specific objects in validation layer messages, graphics
/// debuggers, and profiling tools.
///
/// The trait is automatically implemented for any type that implements both `HasDevice`
/// and `AsVkHandle`, which includes most Vulkan wrapper types in this crate.
pub trait DebugObject: crate::HasDevice + crate::utils::AsVkHandle {
    /// Sets a debug name for this Vulkan object.
    ///
    /// The name will be visible in validation layer messages and debugging tools.
    /// If setting the name fails, the error is silently ignored.
    ///
    /// # Parameters
    ///
    /// * `cstr` - A null-terminated C string containing the debug name
    ///
    /// # Example
    ///
    /// ```rust
    /// #
    /// use pumicite::{Device, buffer::Buffer, Allocator, ash::vk};
    /// let (device, _) = Device::create_system_default().unwrap();
    /// let allocator = Allocator::new(device.clone()).unwrap();
    /// #
    /// use pumicite::debug::DebugObject;
    /// let mut buffer = Buffer::new_private(allocator, 128, 4, vk::BufferUsageFlags::VERTEX_BUFFER).unwrap();
    /// buffer.set_name(c"MyVertexBuffer");
    /// ```
    fn set_name(&mut self, cstr: &CStr) {
        let handle = self.vk_handle();
        self.device().set_debug_name(handle, cstr).ok();
    }

    /// Sets a debug name for this Vulkan object and returns the object (builder pattern).
    ///
    /// This is a convenience method that allows chaining the name assignment
    /// during object construction.
    ///
    /// # Parameters
    ///
    /// * `name` - A null-terminated C string containing the debug name
    ///
    /// # Returns
    ///
    /// The object with the debug name set
    ///
    /// # Example
    ///
    /// ```rust
    /// #
    /// use pumicite::{Device, buffer::Buffer, Allocator, ash::vk};
    /// let (device, _) = Device::create_system_default().unwrap();
    /// let allocator = Allocator::new(device.clone()).unwrap();
    /// #
    ///
    /// use pumicite::debug::DebugObject;
    /// let buffer = Buffer::new_private(allocator, 128, 4, vk::BufferUsageFlags::VERTEX_BUFFER)
    ///     .unwrap()
    ///     .with_name(c"MyVertexBuffer");
    /// ```
    fn with_name(mut self, name: &CStr) -> Self
    where
        Self: Sized,
    {
        self.set_name(name);
        self
    }

    /// Removes the debug name from this Vulkan object.
    ///
    /// # Returns
    ///
    /// * `Ok(())` if the name was successfully removed
    /// * `Err(VkResult)` if the operation failed
    fn remove_name(&mut self) -> VkResult<()> {
        let handle = self.vk_handle();
        self.device().remove_debug_name(handle)
    }
}

/// Blanket implementation of DebugObject for all types that have a device and Vulkan handle
impl<T> DebugObject for T where T: crate::HasDevice + crate::utils::AsVkHandle {}

impl crate::Device {
    /// Sets a debug name for a Vulkan object handle.
    ///
    /// This method directly sets a debug name for any Vulkan handle type.
    ///
    /// Users are normally expected to call [`VkResult::ok`] on the returned result if
    /// it's acceptible for the operation to fail (e.g., debug utils extension not available)
    pub fn set_debug_name<T: ash::vk::Handle + Copy>(
        &self,
        handle: T,
        name: &CStr,
    ) -> VkResult<()> {
        unsafe {
            let object_handle = handle.as_raw();
            self.get_extension::<DebugUtilsExt>()?
                .set_debug_utils_object_name(&vk::DebugUtilsObjectNameInfoEXT {
                    object_type: T::TYPE,
                    object_handle,
                    p_object_name: name.as_ptr(),
                    ..Default::default()
                })
        }
    }

    /// Removes the debug name from a Vulkan object handle.
    ///
    /// This method clears any previously set debug name for the specified handle.
    pub fn remove_debug_name<T: ash::vk::Handle + Copy>(&self, handle: T) -> VkResult<()> {
        unsafe {
            let object_handle = handle.as_raw();
            self.get_extension::<DebugUtilsExt>()?
                .set_debug_utils_object_name(&vk::DebugUtilsObjectNameInfoEXT {
                    object_type: T::TYPE,
                    object_handle,
                    ..Default::default()
                })
        }
    }
}
